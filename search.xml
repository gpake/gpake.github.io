<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[试着读一下 SIL]]></title>
    <url>%2F2019%2F03%2F06%2FtryToReadSIL%2F</url>
    <content type="text"><![CDATA[这是 Swift 摸鱼系列的第二篇 上篇讲的是 Swift 底层是怎么调度方法的 这篇我们说一下探究 Swift 运行过程中最常用的工具之一：Swift Intermediate Language (SIL) Swift Intermediate Language (SIL)平常我们写 Swift 不用关心编译器怎么工作，了解底层逻辑可以帮你更好的理解语言本身的思想。 SIL 是一个专门为 Swift 定制，为了进行后续优化的语言。 这里我们不过多的介绍文档上的内容，而是关注它在解析中反映出 Swift 的底层逻辑。 例子下面那一段例子来简单解释一下 SIL， 其实 SIL 也是一种语言，语法结构清晰，可以将我们使用高级语言被隐藏的很多细节都重新渲染出来，帮助我们理解语言实现的逻辑。 直接上代码： 对于一个简单的 class 声明和调用 1234567class TestClass &#123; func testFunc() &#123; print("ahaha") &#125;&#125;TestClass().testFunc() 使用 swiftc -emit-silgen -Onone test.swift &gt; test.swift.sil 可以生成 SIL，文件会有大概 200 行。SIL 文件点这里 例子解析接下来我们一段一段分析： 头部声明1234567891011sil_stage rawimport Builtinimport Swiftimport SwiftShimsclass TestClass &#123; func testFunc() init() deinit&#125; sil_stage raw 是 SIL 的一个阶段，如果进行 guaranteed transformations 后，就可以生成 canonical 的 SIL 也可以使用下面的指令生成swiftc -emit-sil -Onone test.swift &gt; test.swift.sil 紧接着就是 import 和声明 调用接下来是重头戏，方法的实现和调用 1234567891011121314151617// mainsil @main : $@convention(c) (Int32, UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;) -&gt; Int32 &#123;bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&lt;Optional&lt;UnsafeMutablePointer&lt;Int8&gt;&gt;&gt;): %2 = metatype $@thick TestClass.Type // user: %4 // function_ref TestClass.__allocating_init() %3 = function_ref @$S4test9TestClassCACycfC : $@convention(method) (@thick TestClass.Type) -&gt; @owned TestClass // user: %4 %4 = apply %3(%2) : $@convention(method) (@thick TestClass.Type) -&gt; @owned TestClass // users: %7, %6, %5 %5 = class_method %4 : $TestClass, #TestClass.testFunc!1 : (TestClass) -&gt; () -&gt; (), $@convention(method) (@guaranteed TestClass) -&gt; () // user: %6 %6 = apply %5(%4) : $@convention(method) (@guaranteed TestClass) -&gt; () destroy_value %4 : $TestClass // id: %7 %8 = integer_literal $Builtin.Int32, 0 // user: %9 %9 = struct $Int32 (%8 : $Builtin.Int32) // user: %10 return %9 : $Int32 // id: %10&#125; // end sil function 'main' 先看 main 函数，可以看出 SIL 语法清晰，结构也不复杂。根据单词我们也大概可以猜出他的作用。 metatype 获得类型function_ref 获得函数地址的引用apply 调用函数destroy_value 清理内存 如果你想知道具体命令具体是如何工作的，可以看看：https://github.com/apple/swift/blob/master/docs/SIL.rst 上面分成五段第一段声明函数，拿到 metatype，把类型赋值给 %2第二段调用 init 函数第三段调用 testFunc 函数第四段销毁不需要的变量第五段 return 每个表达式右侧都有 // user: %7, %6, %5 或者 // id: %7 其实是定位注释// user: %7 说明改赋值句的结果，会被 id 是 7 的表达式用到，赋值语句都会注释使用者是谁// id: %7 说明这句的 id 就是 7，非赋值语句都会标注 id 是什么没有标注 id 的怎么办？找到最近的一个 id，往上往下数就好啦，一行语句 id 增加 1。 其中我们之前提到过 class 中实例方法都会用 vtable 调用，vtable 调用的特点就是通过 class_method 拿到函数引用，然后交由 apply 调用。 SIL 文件底部就是我们一直提到的 vtable12345sil_vtable TestClass &#123; \#TestClass.testFunc!1: (TestClass) -&gt; () -&gt; () : @$S4test9TestClassC0A4FuncyyF // TestClass.testFunc() \#TestClass.init!initializer.1: (TestClass.Type) -&gt; () -&gt; TestClass : @$S4test9TestClassCACycfc // TestClass.init() \#TestClass.deinit!deallocator: @$S4test9TestClassCfD // TestClass.__deallocating_deinit&#125; @$S4test9TestClassC0A4FuncyyF 表示这个方法的类型是：test.TestClass.testFunc() -&gt; ()这个技术叫做 Name demangle 后面我们会讲到。 Protocol 的调用同样的，我们也可以看看 protocol 的 witness 是什么样的有 protocol 12345678910111213protocol aProtocol &#123; func testFunc()&#125;// extension aProtocol &#123;// func testFunc() &#123;&#125;// &#125;class aStruct: aProtocol &#123; func testFunc() &#123;&#125; // override defualt implementation&#125;// let ins = aStruct()// ins.testFunc()let proto: aProtocol = aStruct()proto.testFunc() 可以得到1234567891011121314151617181920212223242526272829303132// 1==========// main%10 = witness_method $@opened("7EA915EE-3F22-11E9-9F70-784F4386410B") aProtocol, #aProtocol.testFunc!1 : &lt;Self where Self : aProtocol&gt; (Self) -&gt; () -&gt; (), %9 : $*@opened("7EA915EE-3F22-11E9-9F70-784F4386410B") aProtocol : $@convention(witness_method: aProtocol) &lt;τ_0_0 where τ_0_0 : aProtocol&gt; (@in_guaranteed τ_0_0) -&gt; () // type-defs: %9; user: %11 %11 = apply %10&lt;@opened("7EA915EE-3F22-11E9-9F70-784F4386410B") aProtocol&gt;(%9) : $@convention(witness_method: aProtocol) &lt;τ_0_0 where τ_0_0 : aProtocol&gt; (@in_guaranteed τ_0_0) -&gt; () // type-defs: %9// 2==========// protocol witness for aProtocol.testFunc() in conformance aStructsil private [transparent] [thunk] @$S4test7aStructCAA9aProtocolA2aDP0A4FuncyyFTW : $@convention(witness_method: aProtocol) (@in_guaranteed aStruct) -&gt; () &#123;// %0 // users: %5, %1bb0(%0 : $*aStruct): %1 = load_borrow %0 : $*aStruct // users: %5, %3, %2 %2 = class_method %1 : $aStruct, #aStruct.testFunc!1 : (aStruct) -&gt; () -&gt; (), $@convention(method) (@guaranteed aStruct) -&gt; () // user: %3 %3 = apply %2(%1) : $@convention(method) (@guaranteed aStruct) -&gt; () %4 = tuple () // user: %6 end_borrow %1 from %0 : $aStruct, $*aStruct // id: %5 return %4 : $() // id: %6&#125; // end sil function '$S4test7aStructCAA9aProtocolA2aDP0A4FuncyyFTW'// 3==========sil_vtable aStruct &#123; \#aStruct.testFunc!1: (aStruct) -&gt; () -&gt; () : @$S4test7aStructC0A4FuncyyF // aStruct.testFunc() \#aStruct.init!initializer.1: (aStruct.Type) -&gt; () -&gt; aStruct : @$S4test7aStructCACycfc // aStruct.init() \#aStruct.deinit!deallocator: @$S4test7aStructCfD // aStruct.__deallocating_deinit&#125;// 4==========sil_witness_table hidden aStruct: aProtocol module test &#123; method #aProtocol.testFunc!1: &lt;Self where Self : aProtocol&gt; (Self) -&gt; () -&gt; () : @$S4test7aStructCAA9aProtocolA2aDP0A4FuncyyFTW // protocol witness for aProtocol.testFunc() in conformance aStruct&#125; //1 在 main 中通过 witness_method 拿到了一个函数指针，然后直接进行 apply继续往下看，根据我们以往的只是 witness_method 是通过查表得到的函数地址//4 文件底部就是我们要找的 sil_witness_table 在后面的注释有一个 demangle 的函数签名//2 通过字符串搜索，我们可以找到 witness 的函数实现//3 他在内部进行了 class_method 查找和调用，最终指向 sil_vtable 中的方法 通过这个我们可以很清楚的看到 witness table 做的不是一个引用，而是指向一个 witness 调用函数。这个函数内部只做了一件事，就是调用真正实现协议的方法。 从 SIL 的角度来说，使用协议调用的性能成本还是很明显的。多一次查表，多一次调用。 根据注释我们还可以得出：witness 函数会针对每个实现了协议的对象都生成一份映射感兴趣的话，可以找找看 SIL 文件中是不是有我们猜想的证据。 结语总的来说，SIL 不像 IR 或者汇编一样逻辑复杂或是晦涩难懂。基于你对 Swift 的认知可以很轻松的读懂 SIL，并借此来帮助你分析一些程序中一些被隐藏的细节。 想更多的了解 SIL，不妨去读一下官方文档吧 https://github.com/apple/swift/blob/master/docs/SIL.rst]]></content>
  </entry>
  <entry>
    <title><![CDATA[Swift 底层是怎么调度方法的]]></title>
    <url>%2F2019%2F02%2F11%2FswiftMethodDispatchBrief%2F</url>
    <content type="text"><![CDATA[经过多年的发展和前辈们的科普，我们都对 Objective-C 的 Method Lookup 机制了然于胸。但是 Swift 是怎么进行方法派发 ( dispatch ) 的，倒是一个不太被常问到的一个问题。不妨一起来看一看。 TL;DR怎么让你的代码在运行时更快？ 全文针对 Swift 4.2 尽量使用 值类型，final 用 private 等缩小访问权限，开启 Whole Module Optimization 给协议添加默认实现 下表为 Swift 对象的派发方式与关键字的关系。 对象\派发方式 Static VTable Witness Table Message Value Type 默认行为 N/A : protocol N/A Swift Class finalextension 默认行为 : protocol dynamic NSObject finalextension 默认行为 : protocol dynamic Protocol extension 默认行为 N/A : NSObjectProtocol@objc 注意：Witness Table 仅在调用对象类型为 Protocol 类型时，才会被引用。 Swift 的派发类别观察现代编译语言的派发方式一般分为静态和动态，如果你不清楚他们的特性，可以往下看。 下面我们从常用的数据类型为视角，分为 Type 和 Protocol 详细说明。 SIL 的观察结果 下面两张图引用自赵新宇老师曾经做的，他的图全面而且好看。 根据 WWDC 和 Swift 文档，我们知道 SIL (Swift Intermediate Language) 是 Swift 的编译器中间产物，通过阅读生成的中间代码，我们可以观察到在语言运作层面的一些操作手法。 关于 SIL 我计划写一篇介绍文章，敬请期待。 首先我们观察一下 Type 类型： 可以看到，除了原始声明，会产生影响的就是 @objc , dynamic 和 final 这三个关键字了。 Value Typestruct, enum 这样的值类型不支持继承，所以无需动态派发，它所有的方法调用（包括遵守的协议方法），都是直接调用。 虽然不支持继承，但值类型还是可以通过 extension 和 Protocol 可以实现扩展。 Class Type对于一个纯 Swift class 来说，默认使用 Table 派发，影响它方法调用的关键字有 final、 dynamic 和 extension。 函数如果被标记成 final ，编译器就会知道这个方法不会被 override，并把它的调用方式标记成直接调用。而对于未标记成 final 并在 class 内部（非 extension）中定义的方法，Swift 会用一种叫作 Virtual Table 的机制来在运行时查找到这个方法并进行调用。 当一个方法被标记为 dymanic，你必须同时把它标记上 @objc，此时这个方法会使用 Message 调用，依赖 Objc runtime。 因为定义在 extension 中的方法目前还不支持 override，所以定义在其中的方法都是直接派发的。 NSObject Subclass影响这种类型的函数调用方式的关键字和上面一样，但是表现却不完全一样。 标记为 final 和 dynamic 的函数可以参考上面的 class。 在原生声明（非 extension）中定义的普通方法和标记为 @objc 的方法都使用 V-Table 机制派发。用 Swift 编写的类是不能被 Objective-C 继承的，@objc 只是把方法暴露给 Objective-C，并没有改变方法派发的本质。 Extension 中的方法是直接派发的，但标记为 @objc 的函数需要对 Objc runtime 可见，就变成了 Message 派发。而且加不加 dynamic 生成的底层代码是一样的，这里怀疑是编译器隐式的加上了 dynamic 关键字。 ProtocolProtocol 是一个比较特殊的情况，不同于 Objective-C，Swift 在对待 Protocol 方法调用时更重视实例的类型，而不是实例的内在（比如 Objc 中的 isa）。 下面先看看现象： 对于 protocol 的默认实现，使用的是 static 方式。 对于实现了 Protocol 的对象，无论是值类型还是引用类型： 向对象自己的实例调用，效果和没有 Protocol 的状态一样； 把对象类型转换为 Protocol 类型，则会通过 Witness Table 进行派发 如果你一脸懵逼的看到这里，那么恭喜你，下面还有一大段内容可以帮助你理解这些。 Swift 派发原理Dispatch 是什么 Dispatch 派发，指的是语言底层找到用户想要调用的方法，并执行调用过程的动作。Call 调用，指的是语言在高级层面，指示一个函数进行相关命令的行为。 对于一个编译型语言来说，一般有三种方式可以派发到方法：静态派发，基于 Table 的派发，消息派发。 Java 默认是使用 Table 方式派发的，你可以使用 final 关键字来强制动态派发。 C++ 默认是静态派发的，你可以使用 virtual 关键字来启用 Table 派发。 Objective-C 全都基于消息派发，不过也允许你使用 C level 的函数直接派发。 Swift 则巧妙的使用了这三种方法，分别应对不同的情况。 Dispatch 的种类 派发的方法虽然不同，但主要是性能和灵活性的不同妥协。 Direct Dispatch 直接派发直接派发（静态派发）最快。不只是因为他的汇编命令少，还因为他可以应用很多编译器黑魔法，比如 inline 优化等。 不过这种方式局限性最大，因为不够动态而无法支持子类。 Table 派发基于 Table 的派发机制是编译语言最常用的方式，Table 一般是用函数地址的数组来存储每个类的声明。大多数语言包括 Swift 都把这个称作 VTable，不过 Swift 中还有一个术语叫做 Witness Table 是服务于 Protocol 的，下面会提到。 每个子类都会有自己的 VTable 副本，子类中 override 的方法指针也会被替换成新的，子类新添加的方法则会被添加在 Table 的尾部。程序会在运行时确定每个函数具体的地址。 表的查找就实现而言非常简单，而且性能可以预测，不过还是比直接派发更慢一些。从字节码的角度来说，这种方法多了两步查找和一部跳转，这些都是开销。而且，这种方法没法使用一些黑魔法来优化。 另一个不好的点在于，这种基于数组的派发让 extension 没法扩展这个 table。因为在子类添加方法列表到尾部后，extension 就没有一个安全的 index 可以添加他的方法到 table 中。这里介绍了更多的细节https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001922.html Message 派发Message 派发是最灵活的派发方式。他是 Cocoa 的基石，也是 KVO，UIAppearance，Core Data 的核心。 他的关键功能是可以让开发者在运行时改变消息发送的行为。不仅可以通过 swizzling 修改 method，还可以通过 isa-swizzling 来修改对象。 一旦有消息发出，runtime 就会基于继承关系开始查找，虽然听起来很慢，但是有 cache 做保障，一旦 cache 经过预热，就和 Table 方式差不多快了。 这篇文章 有一些更深入的说明。 Swift Dispatch 的方式会影响派发方式的可能Swift 用什么派发方式？可以从下面四个方面来说： 声明位置 引用类型 关键字的影响 可见性的影响 声明所在位置的影响我们可以在 extension 中声明一个方法，也可以在原始对象中声明。他们是有区别的 extension 中会直接使用静态派发 原始声明 extension Value Type Static Static Protocol N/A Static Class V-Table Static NSObject 子类 V-Table Message (@objc) 引用类型的影响1234567891011121314151617181920212223protocol MyProtocol &#123; &#125; struct MyStruct: MyProtocol &#123;&#125;extension MyStruct &#123; func extensionMethod() &#123; print("In Struct") &#125;&#125;extension MyProtocol &#123; func extensionMethod() &#123; print("In Protocol") &#125;&#125;let myStruct = MyStruct()let proto: MyProtocol = myStructmyStruct.extensionMethod() // -&gt; “In Struct”proto.extensionMethod() // -&gt; “In Protocol” 调用 proto.extensionMethod() 不会走 struct 的实现，只有对 protocol 可见的方法才会被调用。 如果 extensionMethod() 的声明放在 protocol 里，那 proto.extensionMethod() 就会走 struct 的实现了。 从 SIL 的角度来说，如果不写在 protocol 声明中，witness table 无法把协议和类的函数产生映射关系，所以他无法 witness 实现协议的对象，只能按照默认实现进行直接派发执行了。 关键字的影响final使用了 final 的，都用静态派发，因为 final 意味着完全没有动态性。final 用于类型，或是 function，都会造成这样的情况。 而且 final 作用范围的方法，都不会被 export 到 OC runtime，也不会生成 selector dynamic使用了 dynamic 的 class （只有 class 可以 dynamic），会开启 message 模式，让 OC runtime 可以调用。 必须 @import Foundation，必须有 @objc，如果是 class，还必须是 NSObject 的子类 延展阅读： dynamic vs @objc: dynamic 是强制使用 message 派发，KVO 需要。@objc 只是 export 给 objc，swift 还是静态派发 @objc / @nonobjc@objc / @nonobjc 控制方法对于 objc 的可见性。但是不会改变 swift 中的函数如何被派发。 @nonobjc 可以禁止函数使用 message 派发 （和 final 在汇编上看起来类似，偏向于使用 final)// 并不会这样，@nonobjc 依然是使用 Table 调用，但是 @nonobjc 之后无法使用 dynamic，会提示 error: a declaration cannot be both &#39;@nonobjc&#39; and &#39;dynamic&#39; @objc 的原理是生成两个函数引用，一个给 swift 调用，一个给 objc 调用 @objc final func aFunc() {} 会让消息使用直接派发，不过依然会 export 给 objc， @inline@inline 可以告诉编译器去优化直接派发的性能。 see: https://github.com/vandadnp/swift-weekly/blob/master/issue11/README.md#inline @inline 可以给生成的函数加上标记，后期编译器进行指定的优化 inline 可以选择的参数有两个 never 和 __always 对于 inline 的使用建议： 0，默认行为是编译器自己决定要不要使用 inline 进行优化，你也应该保持默认行为。 1，如果你的函数特别长，你不想让你的打包体积变得特别大，可以使用 @inline(never) 2，如果你的函数很小，你希望他可以快一点，就可以使用 @inline(__always)，不过其实编译器也会帮你做这样的事情，所以你这么做也基本上不会让他变得更快 有趣的是，如果你用 dynamic @inline(__always) func dynamicOrDirect() {} 依然会得到一个 message 派发的函数。 不过，这个没什么意义，应该是未定义的行为，忽略就好。 关键字总结 class Value Type Protocol extension func 备注 final Static Static Static Static Static @objc final dynamic N/A N/A Message必须 import Foundation 必须 @objc protocol | 只有 class 的才可以 | Message必须 import Foundation必须 @objc | || inline | 根据属性决定直接派发的编译器优化行为，不影响派发原理。 | | | | | | 方法可见性的影响Swift 编译器会尽可能的帮你优化派发，比如：你的方法没有被继承，那他就会注意到这个，并用尝试使用直接派发来优化性能。 KVO值得注意的是 KVO，被观察的属性也必须被声明为 dynamic，否则 setter 会走直接派发，无法触发变化。 https://developer.apple.com/swift/blog/?id=27&gt; 这篇文章里有更多关于优化的细节。 关于派发方式的总结：派发方式有两种，动态派发也有两种： 静态派发 动态派发 Table 派发 （基于 Virtual Table） Message 派发（基于 Objc Runtime） 派发效率从高到低为： 直接派发 &gt; Table 派发 &gt; Message 派发 回到文章开头的关键字影响表格： 对象\派发方式 Static VTable Witness Table Message Value Type 默认行为 N/A : protocol N/A Swift Class finalextension 默认行为 : protocol dynamic NSObject finalextension 默认行为 : protocol dynamic Protocol extension 默认行为 N/A : NSObjectProtocol@objc 性能建议；使用 final， private ，Whole Module Optimization final 可以标记在一个 class, 属性或方法之前，表示这个对象无法被继承 / 覆盖。编译器会因此把关于这个对象的派发改变为直接派发。 private 可以标记一个对象的可见性，因为都在同一个文件内，所以编译器可以确定这个对象的继承情况，从而推断出你的方法可以被标记为 final。如果没有继承， 默认的方法可见性是 internal，这就代表着，如果你启用 Whole Module Optimization ，编译器就可以知道你的 internal 方法是否有被继承，如果没有的话，他们也会被优化为直接派发。 在用户无感知的情况下，越快越好，所以能直接派发的，就不用 Table 备注 @objc / @nonobjc 只影响可见性，dynamic 才是真正产生影响的那个 协议方法的默认实现被覆盖也会走类型本身的派发方式，在 AST 阶段就确定好了的 问题 为什么 extension 中静态派发为什么无法和负责可见性的 @objc 共存？ Reference Understanding Swift Performance - Apple WWDC 2016 Optimizing Swift Performance - Apple WWDC 2015 Method Dispatch in Swift - Raizlabs Swift 中的方法调用（Method Dispatch）（一） - 概述]]></content>
      <tags>
        <tag>swift method dispatch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Currying]]></title>
    <url>%2F2019%2F02%2F02%2FswiftCurrying%2F</url>
    <content type="text"><![CDATA[TL;DRSwift 中的实例方法是柯里化的。本质是把 self 当做隐式参数的类方法，它会返回一个给实例用的函数。 我们先定义一个简单的 struct，然后调用： 12345678910struct aCls &#123; func aFunc() &#123;&#125; func aPrint(str: String) &#123; print(str) &#125; &#125; let ins = aCls() ins.aFunc() ins.aPrint(str: "Hello") 其实，系统是这么帮你处理的12aCls.aFunc(ins)() aCls.aPrint(ins)(str: "Hello") 最近在看 Swift 方法调用这方面的内容，这篇也是方法调用系列的一个番外篇。 柯里化如果你还不了解 Currying，可以看这里 柯里化 (CURRYING) wikipedia: Currying swift-evolution: Removing currying func declaration syntax 虽然 Swift 3 已经把这玩意去掉了，不过这个概念还是对降低程序复杂度有一些帮助的。 发生了什么？我们在这里使用 SIL 来进行辅助分析，如果你还不了解 SIL，先自己查查，我后面会有一篇专门说这个。 还是拿着上面的类声明来看。 1234567891011struct aCls &#123; var aPropStr: String = "Hello" func aFunc() &#123;&#125; func aPrint(str: String) &#123; print(self.aPropStr) &#125; &#125; let ins = aCls() ins.aFunc() ins.aPrint(str: "Hello") 可以得到一大串代码，我们简单清理一下，得到如下： 123456789101112131415161718192021222324252627282930// aCls.aFunc() sil hidden @$S4test4aClsV5aFuncyyF : $@convention(method) (aCls) -&gt; () &#123; // %0 // user: %1 bb0(%0 : $aCls): debug_value %0 : $aCls, let, name "self", argno 1 // id: %1 %2 = tuple () // user: %3 return %2 : $() // id: %3 &#125; // end sil function '$S4test4aClsV5aFuncyyF'// -------------------// aCls.aPrint(str:) sil hidden @$S4test4aClsV6aPrint3strySS_tF : $@convention(method) (@guaranteed String, @guaranteed aCls) -&gt; () &#123; // %0 // user: %2 // %1 // users: %14, %3 bb0(%0 : $String, %1 : $aCls): debug_value %0 : $String, let, name "str", argno 1 // id: %2 debug_value %1 : $aCls, let, name "self", argno 2 // id: %3 %4 = integer_literal $Builtin.Word, 1 // user: %6 // function_ref _allocateUninitializedArray&lt;A&gt;(_:) // init // 取出 aPropStr，copy 值（因为 String 是当做值类型操作的） %14 = struct_extract %1 : $aCls, #aCls.aPropStr // user: %15 %15 = copy_value %14 : $String // user: %17 %16 = init_existential_addr %13 : $*Any, $String // user: %17 store %15 to [init] %16 : $*String // id: %17 /* ... */ &#125; 可以看到 SIL 中只有 aCls.aFunc(), aCls.aPrint(str:) 的声明实现，并没有表现出实例相关的方法。12345// aCls.aFunc()bb0(%0 : $aCls):// aCls.aPrint(str:)bb0(%0 : $String, %1 : $aCls): 而且在两处 bb0 这行，你可以看到参数列表的最后一位是一个 aCls 类型的对象，也就是实例对象。 进一步，我们调用实例变量就可以看到这个实例参数会被怎么使用了，比如在 aPrint(str:) 方法中我们调用了一个实例属性。 12345678// aCls.aPrint(str:)bb0(%0 : $String, %1 : $aCls):// 取出 aPropStr，并 copy 值（因为 String 是当做值类型操作的） %14 = struct_extract %1 : $aCls, #aCls.aPropStr // user: %15 %15 = copy_value %14 : $String // user: %17 %16 = init_existential_addr %13 : $*Any, $String // user: %17 store %15 to [init] %16 : $*String // id: %17 可以看到通过传入的实例，来进行和实例有关的操作，比如读取 property：bb0 %1: aCls 拿到实例变量%14 = struct_extract %1 : $aCls, #aCls.aPropStr // user: %15 取出属性的值，并在下面进行 copy 等操作。 总结柯里化是一种很好的拆分思想，可以在有重复操作的情况下降低耦合，提高代码复用性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Swift 如何给回调添加 @escaping 和 optional]]></title>
    <url>%2F2018%2F12%2F12%2FswiftEscapingOptional%2F</url>
    <content type="text"><![CDATA[TL;DRSwift 中写 1func aFunc(callback: @escaping (() -&gt; Void)?) &#123;&#125; 这么声明函数你会得到一个错误： 123@escaping attribute only applies to function types// clang 会建议你Replace &apos;@escaping &apos; with &apos;&apos; 请接受他的建议，去掉 @escaping，留下参数的可选型 ? 因为从 Swift 4 之后只有闭包 (Closure) 才会被隐式的标记为 nonescaping ，其他参数默认依然是 escaping 的。 同样的，给一个在方法参数中给一个 String 添加 @escaping 也会得到同样的报错和建议： 12func tNormal(aStr: @escaping String) &#123;&#125;// @escaping attribute only applies to function types 为什么？因为 optional 在 swift 中其实是一个 enum 但是 enum 和 @escaping 有什么关系，一个是可选值，一个是生命周期。 关于生命周期Swift 中函数的参数除了值类型默认都是递交生命周期管理权的，但是 closure 是一个特别的存在，因为他需要捕捉上下文中引用到的变量。 Swift 3 和之前默认所有参数都是 @escaping 的，closure 也不例外。一方面 Objective-C 就是这么处理的，一方面别的参数也这样。 不过这样用起来很不安全，一旦使用者不注意，就会循环引用。 所以在 Swift 4 开始，所有的 closure 都被默认处理为 @nonescaping ，来让使用者对闭包的生命周期有更强烈的感知。 回到 escaping 的问题基于上面对参数声明周期的描述，我们可以知道，一旦闭包类型被声明为可选值后，他就会被一个 enum 捕捉，这时候他就成为了一个普通类型，而不是 closure。 所以编译系统不会对他进行特殊处理，默认也就是 escaping 的了。 @escaping 和 optional 有什么区别？结论：在声明周期上没有区别，我们可以用两段代码简单的对比一下： 这里用一个 iOSViewPlayground 来进行测试，环境基本和虚拟机一致。 宿主持续存在，是否会被提前释放？ 宿主不存在后，闭包的生命周期是怎样的，宿主的生命周期是怎样的，捕获值的生命周期是怎样的？ 宿主持续存在1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950typealias Handler = () -&gt; Voidclass MyViewController : UIViewController &#123; override func loadView() &#123; let view = UIView() view.backgroundColor = .white self.view = view &#125; override func viewDidLoad() &#123; super.viewDidLoad() let t = testClass() t.tOptional &#123; [weak self] in self?.pr(str: "in optinal caller") &#125; t.tEscaping &#123; [weak self] in self?.pr(str: "in escaping caller") &#125; let s = Closure &#123; [weak self] in print("super pre struct self:\(self)") self?.pr(str: "super in struct") &#125; &#125; func pr(str: String) &#123; print(str) &#125;&#125;class testClass: NSObject &#123; deinit &#123; print("testClass deinit") &#125; func tOptional(callback: Handler?) &#123; DispatchQueue.main.asyncAfter(deadline: .now() + 1) &#123; print("optinal: \(callback)") callback?() &#125; &#125; func tEscaping(callback: @escaping Handler) &#123; DispatchQueue.main.asyncAfter(deadline: .now() + 1) &#123; print("escaping: \(callback)") callback() &#125; &#125;&#125; 得到 console 可以看出，执行的 class 已经 deinit，callback 中的方法继续正常执行，打印出了我们期望的内容，说明在这个 case 下，escaping 和 optional 的效果是一样的。 123456testClass deinitoptinal: Optional((Function))in optinal callerescaping: (Function)in escaping caller 即使对象先释放了，也可以正确的进行回调 宿主被释放后的效果和上面的代码结构类似 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879typealias Handler = () -&gt; Voidstruct Closure &#123; let handler: Handler&#125;class MyViewController : UIViewController &#123; override func loadView() &#123; let view = UIView() view.backgroundColor = .white self.view = view &#125; override func viewDidLoad() &#123; super.viewDidLoad() let t = testClass() // Closure 中 self 消失的 case t.test() // Closure 中 self 不消失的 case let s = Closure &#123; [weak self] in print("super pre struct self:\(self)") self?.pr(str: "super in struct") &#125; t.testStruct(aStruct: s) &#125; func pr(str: String) &#123; print(str) &#125;&#125;class testClass: NSObject &#123; deinit &#123; print("testClass deinit") &#125; func pr(str: String) &#123; print(str) &#125; func test() &#123; tOptional &#123; [weak self] in print("pre optonal self:\(self)") self?.pr(str: "optinal") &#125; tEscaping &#123; [weak self] in print("pre escaping self:\(self)") self?.pr(str: "escaping") &#125; let s = Closure &#123; [weak self] in print("pre struct self:\(self)") self?.pr(str: "in struct") &#125; testStruct(aStruct: s) &#125; func tOptional(callback: Handler?) &#123; DispatchQueue.main.asyncAfter(deadline: .now() + 1) &#123; print("optinal: \(callback)") callback?() &#125; &#125; func tEscaping(callback: @escaping Handler) &#123; DispatchQueue.main.asyncAfter(deadline: .now() + 1) &#123; print("escaping: \(callback)") callback() &#125; &#125; func testStruct(aStruct: Closure) &#123; DispatchQueue.main.asyncAfter(deadline: .now() + 1) &#123; print("struct: \(aStruct)") aStruct.handler() &#125; &#125;&#125; 得到 console 在 testclass 中调用的内容，都因为 testclass (self) 被释放而无法继续，但是闭包除了捕获值以外的部分，还是在正常执行的。 123456789101112testClass deinitoptinal: Optional((Function))pre optonal self:nilescaping: (Function)pre escaping self:nilstruct: Closure(handler: (Function))pre struct self:nilstruct: Closure(handler: (Function))super pre struct self:Optional(&lt;__lldb_expr_8.MyViewController: 0x7f8a471047e0&gt;)super in struct 结论对于可以传空的 closure，大胆使用 ? 即可，不用担心 @escaping 的声明周期问题。备注最后对基于异步调用的函数参数类型和系统报错给个例子： 1234567891011121314151617181920func aClosureError(callback: Handler) &#123; DispatchQueue.main.async &#123; print("\(callback)") // Closure use of non-escaping parameter 'callback' may allow it to escape &#125;&#125;// no errorfunc aClosureError(callback: Handler?) &#123; DispatchQueue.main.async &#123; print("\(callback)") &#125;&#125;// no errorfunc aNonClosure(str: String) &#123; DispatchQueue.main.async &#123; print("\(str)") &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[博客系统换成 HEXO + Next 主题]]></title>
    <url>%2F2018%2F10%2F31%2Ftryhexo%2F</url>
    <content type="text"><![CDATA[看看 GitHub.io 上的文章，已经是好三年前的了，人家写了三年文章，我摸了三年鱼。 唏嘘不已。 资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 文章资源文件夹对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml文件中的 post_asset_folder 选项设为 true 来打开。 1_config.ymlpost_asset_folder: true 当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是 markdown ： 1&#123;% asset_img example.jpg This is an example image %&#125; 通过这种方式，图片将会同时出现在文章和主页以及归档页中。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何使用苹果自带的UUID]]></title>
    <url>%2F2015%2F08%2F03%2F2015-08-3-how-to-apple-uuid%2F</url>
    <content type="text"><![CDATA[TL;DR其实苹果以 C 函数的方式提供了 UUID 的方法 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)testUUID&#123; uuid_t u; uuid_t ur; uuid_t ut; uuid_generate(u); uuid_generate_random(ur); uuid_generate_time(ut); char a[16]; uuid_unparse(u, a); char b[16]; uuid_unparse(ur, b); char c[16]; uuid_unparse(ut, c); // printf(&quot;%s\n&quot;, a);// printf(&quot;%s\n&quot;, b); printf(&quot;%s\n&quot;, c);&#125;- (NSString *)uuid&#123; // Create universally unique identifier (object) CFUUIDRef uuidObject = CFUUIDCreate(kCFAllocatorDefault); // Get the string representation of CFUUID object. NSString *uuidStr = (NSString *)CFBridgingRelease(CFUUIDCreateString(kCFAllocatorDefault, uuidObject)); // If needed, here is how to get a representation in bytes, returned as a structure // typedef struct &#123; // UInt8 byte0; // UInt8 byte1; // ... // UInt8 byte15; // &#125; CFUUIDBytes; // CFUUIDBytes bytes = CFUUIDGetUUIDBytes(uuidObject); CFRelease(uuidObject); return uuidStr;&#125; 测试代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//// ViewController.m// test//// Created by Ashbringer on 7/7/15.// Copyright (c) 2015 Dian.fm. All rights reserved.//#import "ViewController.h"//#import "sole-master/sample.cc"#include &lt;uuid/uuid.h&gt;#include &lt;iostream&gt;#include "sole.hpp"int testMethod()&#123; sole::uuid u0 = sole::uuid0(), u1 = sole::uuid1(), u4 = sole::uuid4(); std::cout &lt;&lt; "uuid v0 string : " &lt;&lt; u0 &lt;&lt; std::endl; std::cout &lt;&lt; "uuid v0 base62 : " &lt;&lt; u0.base62() &lt;&lt; std::endl; std::cout &lt;&lt; "uuid v0 pretty : " &lt;&lt; u0.pretty() &lt;&lt; std::endl &lt;&lt; std::endl; std::cout &lt;&lt; "uuid v1 string : " &lt;&lt; u1 &lt;&lt; std::endl; std::cout &lt;&lt; "uuid v1 base62 : " &lt;&lt; u1.base62() &lt;&lt; std::endl; std::cout &lt;&lt; "uuid v1 pretty : " &lt;&lt; u1.pretty() &lt;&lt; std::endl &lt;&lt; std::endl; std::cout &lt;&lt; "uuid v4 string : " &lt;&lt; u4 &lt;&lt; std::endl; std::cout &lt;&lt; "uuid v4 base62 : " &lt;&lt; u4.base62() &lt;&lt; std::endl; std::cout &lt;&lt; "uuid v4 pretty : " &lt;&lt; u4.pretty() &lt;&lt; std::endl &lt;&lt; std::endl; u1 = sole::rebuild("F81D4FAE-7DEC-11D0-A765-00A0C91E6BF6"); u4 = sole::rebuild("GITheR4tLlg-BagIW20DGja"); std::cout &lt;&lt; "uuid v1 rebuilt : " &lt;&lt; u1 &lt;&lt; " -&gt; " &lt;&lt; u1.pretty() &lt;&lt; std::endl; std::cout &lt;&lt; "uuid v4 rebuilt : " &lt;&lt; u4 &lt;&lt; " -&gt; " &lt;&lt; u4.pretty() &lt;&lt; std::endl; return 0;&#125;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. // testMethod(); [self testUUID]; NSLog(@"%@", [self uuid]); for (int i = 0; i &lt; 100; i++) &#123; &#125;&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;- (void)testUUID&#123; uuid_t u; uuid_t ur; uuid_t ut; uuid_generate(u); uuid_generate_random(ur); uuid_generate_time(ut); char a[16]; uuid_unparse(u, a); char b[16]; uuid_unparse(ur, b); char c[16]; uuid_unparse(ut, c); // printf("%s\n", a);// printf("%s\n", b); printf("%s\n", c);&#125;- (NSString *)uuid&#123; // Create universally unique identifier (object) CFUUIDRef uuidObject = CFUUIDCreate(kCFAllocatorDefault); // Get the string representation of CFUUID object. NSString *uuidStr = (NSString *)CFBridgingRelease(CFUUIDCreateString(kCFAllocatorDefault, uuidObject)); // If needed, here is how to get a representation in bytes, returned as a structure // typedef struct &#123; // UInt8 byte0; // UInt8 byte1; // ... // UInt8 byte15; // &#125; CFUUIDBytes; // CFUUIDBytes bytes = CFUUIDGetUUIDBytes(uuidObject); CFRelease(uuidObject); return uuidStr;&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用键盘掌握你的Xcode]]></title>
    <url>%2F2015%2F07%2F31%2F2015-07-31-xcode-with-keyboard%2F</url>
    <content type="text"><![CDATA[要尽量少用鼠标！因为会变成鼠标手！ = =’’’ 哈哈，其实键盘也好不到那里去，但是把手从键盘上移开去找鼠标，然后再定位屏幕上的位置其实是个负担挺大的问题，如果你有不止一块屏幕的话那就更糟了。 好在Xcode为大多数操作都预留了快捷键。下面我会介绍一下我平常是怎么用键盘与Xcode快乐地玩耍的。 Mac 键盘符号首先来看一下这些神奇的符号。来自这里 ⌘ Command ⇧ Shift ⌥ Option ⌃ Control ↩ Return ← ↓ → ↑ 方向键 开胃菜先来点常规的大家都知道的⌘O 打开⌘S 保存（随手保存的好习惯，谨防被Xcode搞崩溃）当然还有我（da jia）最喜欢的⌘C &amp; ⌘V 😂 导航 ⌘1 ⌘2…8 就对应了下图从左到右的八个标签 功能嘛，分别是这些 Navigator（下表中项目==workspace） ⌘+Number Navigator名称 备注 1 Project 项目目录，文件等 2 Symbol 项目中所有的类名和其实现的方法名 3 Find 全项目查找/替换 4 Issue 项目中的 Warning 和 Error 5 Test 项目中的测试 6 Debug 运行时调试区 7 Breakpoint 可爱的断点们 8 Report 编译报告（成功了失败了什么的） 点击其中列出来的条目即可查看对应的代码。 焦点在左侧栏了，还怎么回去敲BUG？！别着急，按一下⌘J 是不是看到了一个可爱的小窗口？！ 它默认就指向代码区，只要一下 ↩ 就可以将焦点转移到代码上了。 当然，你也可以用其他的办法，比如：⌘L。然后你会看到这个： 输入一下行号，然后就可以快速跳转咯。（我觉的还是上面那个快，不过这个在利用 log 查代码的时候悔恨有用，因为 log 一般都会带有出问题代码的行号，对吧对吧？快回答：“是的！”） 哦，顺便说一下，⌘J 之后出现的窗口可以用方向键上下左右哦，快玩玩吧。 右边的那一堆呢？右边是一堆就不叫 Navigator 了，他们叫Inspector。只要⌥⌘ 12345678就可以啦~ 功能嘛，分别是这些 Inspector（下表中项目==workspace） 文本文件状态下: ⌥⌘+Number Inspector名称 备注 1 File 当前文件的属性 2 Quick Help 当前类或方法的帮助，相当于按着⌥点，用鼠标点某个类看到的东西 Xib/Storyboard状态下: ⌥⌘+Number Inspector名称 备注 1 File 当前 xib/storyboard的文件属性，还可以控制是否使用autoLayout, size classes 2 Quick Help 木有帮助 3 Identity 定义当前 View 的标识 4 Attribute 控制 View 的一些属性，比如 title，backgroundColor 5 Size 控制 view 的尺寸，位置，或是constrains 6 Connections 控制IBOutlets Debug View Hierarchy状态下： ⌥⌘+Number Inspector名称 备注 1 File 不可用 2 Quick Help 不可用 3 Object 当前选中 View 的 ClassName 和 内存地址 5 Size 当前选中 View 的 Ui 布局属性]]></content>
      <categories>
        <category>Xcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Core Data的多线程]]></title>
    <url>%2F2015%2F01%2F17%2F2015-01-17-the-core-data-block%2F</url>
    <content type="text"><![CDATA[自己写的程序一直都没什么技术含量，很长一段时间都一直在用NSUserDefaults来做数据持久化。一些小型商业项目也几乎不存什么数据，更多的是展示逻辑和一些简单的数据存储。 最近有机会去处理大量数据，就开开心心的带着bug上路了。 之前的经验一直是在主线程处理所有的逻辑，所以也一直没有遇到什么太复杂的问题，而且UI上都是直接使用NSManagedObject的子类，现在回头看看也是勇敢。 当时还遇到一个问题，我还不大明白，CoreData取出来的数据有时候所有的字段都是nil，对象都是fault的，不知为何，这个会在后面的篇中来说说CoreData的Faulting机制， 苹果并没有 “不推荐” 我们在主线程中使用CoreData，它的默认实现（在建立工程的时候选择使用CoreData就可以看到，苹果在AppDelegate中为我们实现了一套必备代码）也是在主线程中工作的，理所当然的我也一直这么用，直到有一天发现数据多了会阻塞主线程导致卡顿，这时我才想到要分线程来做。 分线程很简单，都是用NSOperationQueue或者GCD，分分钟搞定的问题，虽然看起来也不错，不过偶尔会出现一些无法解释的小问题。 但事实并非如此。后来读了苹果的文档之后才知道CoreData的对象原来完全不能在线程间传递。而应该为每个单独线程指定一个NSManagedObjectContext，但是并不是说自己new一个NSOperationQueue当context在里面操作就好了。 在看了一些文章之后，暂时我理解到的正确的做法应该是这样的： 建立不同的context 使用context的performBlock:等方法来执行任务，而不是自己维护的queue 在不同的context间传递对象应该使用objectID然后使用objectWithID:或existingObjectWithID:error:来在接收context中获取对象 不要或者避免给UI直接使用NSManagedObject而是使用自己的NSObject来传递这样你就可以避免一些空壳数据的情况（往往是UI不知道你删除了CoreData中的数据导致的） 还要注意处理好不同context数据merge的问题 这里引用objc.io的一篇文章的一部分来说明人家的最佳实现 使用下面的代码设置一个 managed object context： 12345678910111213141516- (NSManagedObjectContext *)setupManagedObjectContextWithConcurrencyType:(NSManagedObjectContextConcurrencyType)concurrencyType &#123; NSManagedObjectContext *managedObjectContext = [[NSManagedObjectContext alloc] initWithConcurrencyType:concurrencyType]; managedObjectContext.persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:self.managedObjectModel]; NSError* error; [managedObjectContext.persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:self.storeURL options:nil error:&amp;error]; if (error) &#123; NSLog(@"error: %@", error.localizedDescription); &#125; return managedObjectContext; &#125; 然后我们调用这个方法两次，一次是为主 managed object context，一次是为后台 managed object context： 12self.managedObjectContext = [self setupManagedObjectContextWithConcurrencyType:NSMainQueueConcurrencyType];self.backgroundManagedObjectContext = [self setupManagedObjectContextWithConcurrencyType:NSPrivateQueueConcurrencyType]; 注意传递的参数 NSPrivateQueueConcurrencyType 告诉 Core Data 创建一个独立队列，这将确保后台 managed object context 的运行发生在一个独立的线程中。 现在就剩一步了：每当后台 context 保存后，我们需要更新主线程。我们在之前第 2 期的这篇文章中描述了如何操作。我们注册一下，当 context 保存时得到一个通知，如果是后台 context，调用 mergeChangesFromContextDidSaveNotification: 方法。这就是我们要做的所有事情：1234567891011[[NSNotificationCenter defaultCenter] addObserverForName:NSManagedObjectContextDidSaveNotification object:nil queue:nil usingBlock:^(NSNotification* note) &#123; NSManagedObjectContext *moc = self.managedObjectContext; if (note.object != moc) &#123; [moc performBlock:^()&#123; [moc mergeChangesFromContextDidSaveNotification:note]; &#125;]; &#125; &#125;]; 这儿还有一个小忠告：mergeChangesFromContextDidSaveNotification: 是在 performBlock:中发生的。在我们这个情况下，moc 是主 managed object context，因此，这将会阻塞主线程。 注意你的 UI（即使是只读的）必须有能力处理对象的改变，或者事件的删除。Brent Simmons 最近写了两篇文章，分别是 《Why Use a Custom Notification for Note Deletion》 和 《Deleting Objects in Core Data》。这些文章解释说明了如何面对这些情况，如果你在你的 UI 中显示一个对象，这个对象有可能会发生改变或者被删除。]]></content>
      <categories>
        <category>iOS CoreData</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微小的火光]]></title>
    <url>%2F2015%2F01%2F11%2F2015-01-12-the-first-test%2F</url>
    <content type="text"><![CDATA[说起来，都已经些许年，写过各种各样的bug， 曾经喜欢上这件事是想要玩游戏，到头来却越来越没有时间玩了。 一直在投入时间，可是却愈发觉得瓶颈的阻力。 回过头来冷静看，发觉自己一直都在某个点，没有一点进步。 细来想想，连自己想要走什么样的路都不清楚了。可我还嘲笑别人不知道如何选择自己的专业和工作。真是五十步笑百步。 前辈在半年前就发现了我的问题，要求我写博客。一直拖到现在。 我还是有野心的，虽然我迷了路。 我会努力探索，继续寻找自己的路，护着微小的火光。 夜月明星稀，独挑孤灯。记。]]></content>
      <categories>
        <category>随感</category>
      </categories>
  </entry>
</search>
